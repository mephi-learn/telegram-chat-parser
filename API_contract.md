# Описание API и руководство для разработки клиента

## 1. Цели / Не цели / Ограничения

*   **Цель:** Описать API и схему взаимодействия с сервером, чтобы дать возможность разработать нового клиента для загрузки экспортрованных данных чата Telegram, запуска их обработки и получения обогащенных данных об участниках.
*   **Не цель:** Описание не включает внутреннюю логику работы с Telegram API, процесс развертывания сервера или модификацию самого сервера. Сервер рассматривается как "черный ящик" с известным контрактом.
*   **Ограничения:** Сервер принимает только JSON-файлы с экспортом чата. Максимальный размер файла ограничен 10 МБ.

## 2. Архитектура взаимодействия (Клиент-Сервер)

Взаимодействие с сервером происходит асинхронно по следующей схеме:

1.  **Клиент** инициирует задачу, отправляя файл на сервер.
2.  **HTTP API Server** принимает файл, создает для него уникальную задачу (`task_id`), сохраняет файл во временное хранилище и немедленно отвечает клиенту `202 Accepted` с `task_id`.
3.  **Асинхронный воркер** на сервере в фоновом режиме выполняет ресурсоемкую работу: парсинг файла, извлечение участников и обогащение их данных через Telegram API.
4.  **Клиент** периодически (polling) запрашивает у сервера статус задачи по её `task_id`.
5.  Когда задача выполнена, **клиент** запрашивает и получает финальный результат.

Эта модель позволяет избежать длительного ожидания HTTP-ответа и обеспечивает отказоустойчивость для долгих операций.

## 3. Ключевые сценарии

### Сценарий 1: Успешная обработка (Happy Path)

1.  **Клиент** отправляет `POST /api/v1/process` с телом `multipart/form-data`, содержащим поле `file` с JSON-данными чата.
2.  **Сервер** отвечает `HTTP 202 Accepted` и возвращает JSON: `{ "task_id": "a1b2c3d4-..." }`.
3.  **Клиент** с заданной периодичностью (например, каждые 5 секунд) опрашивает эндпоинт `GET /api/v1/tasks/{task_id}`.
4.  **Сервер** последовательно отвечает `HTTP 200 OK` с JSON, где поле `status` меняется:
    *   `{ "status": "pending", ... }`
    *   `{ "status": "processing", ... }`
    *   `{ "status": "completed", ... }`
5.  Получив статус `completed`, **клиент** запрашивает результат: `GET /api/v1/tasks/{task_id}/result?page=1&page_size=50`.
6.  **Сервер** отвечает `HTTP 200 OK` с пагинированным списком пользователей.

### Сценарий 2: Обработка с ошибкой

1.  Шаги 1-3 аналогичны Happy Path.
2.  В процессе обработки на сервере возникает ошибка (например, невалидный JSON, недоступность Telegram API).
3.  При очередном опросе статуса `GET /api/v1/tasks/{task_id}` **сервер** вернет `HTTP 200 OK` с JSON: `{ "status": "failed", "error_message": "текст ошибки" }`.
4.  **Клиент** должен прекратить опрос и информировать пользователя об ошибке, используя `error_message`.

### Сценарий 3: Запрос по хэшу (кэшированный результат)

1.  **Клиент** отправляет `POST /api/v1/process-by-hash` с JSON-телом: `{ "hash": "sha256-хэш-файла" }`.
2.  **Сервер** отвечает `HTTP 202 Accepted` и возвращает `task_id`.
3.  **Логика на сервере:**
    *   **Если хэш найден в кэше:** Задача почти мгновенно переходит в статус `completed`.
    *   **Если хэш не найден:** Задача переходит в статус `failed` с ошибкой `"File not found in cache..."`.
4.  Клиент опрашивает статус и получает результат как в сценариях 1 или 2.

## 4. API и Контракты данных

Все контракты формально описаны в файле `api_contracts.yaml`.

### Эндпоинты

| Метод | Путь                               | Описание                                     | Тело запроса                                   | Успешный ответ                                                                       |
| :---- | :--------------------------------- | :------------------------------------------- | :--------------------------------------------- | :----------------------------------------------------------------------------------- |
| `POST`  | `/api/v1/process`                  | Запуск новой задачи по файлу                 | `multipart/form-data` с полем `file`           | `202 Accepted` с `{ "task_id": "..." }`                                              |
| `POST`  | `/api/v1/process-by-hash`          | Запуск задачи по хэшу (оптимизация для кэша) | `application/json` с `{ "hash": "..." }`       | `202 Accepted` с `{ "task_id": "..." }`                                              |
| `GET`   | `/api/v1/tasks/{task_id}`          | Получение статуса задачи                     | -                                              | `200 OK` с `{ "task_id": "...", "status": "...", "error_message": "..." }`            |
| `GET`   | `/api/v1/tasks/{task_id}/result`   | Получение результата выполненной задачи      | -                                              | `200 OK` с пагинированным списком `User`                                             |
| `GET`   | `/health`                          | Проверка работоспособности сервера           | -                                              | `200 OK` с `{ "status": "ok" }`                                                      |

### Модели данных

*   **TaskStatus:**
    ```json
    {
      "task_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
      "status": "pending" | "processing" | "completed" | "failed",
      "error_message": "string (пусто, если нет ошибки)"
    }
    ```
*   **User (в результате):**
    ```json
    {
      "id": 123456,
      "name": "Full Name",
      "username": "username",
      "bio": "User bio",
      "channel": "channel_name"
    }
    ```
    *   `channel` (string, optional): Если в `bio` пользователя найдена ссылка на Telegram-канал (вида `@channel_name` или `t.me/channel_name`), здесь будет указано его имя. Поле отсутствует, если канал не найден.
*   **Result (с пагинацией):**
    ```json
    {
      "pagination": {
        "current_page": 1,
        "page_size": 50,
        "total_items": 245,
        "total_pages": 5
      },
      "data": [
        { "...User..." },
        { "...User..." }
      ]
    }
    ```

### Назначение эндпоинта `/api/v1/process-by-hash`

Этот эндпоинт является **оптимизацией** для экономии трафика и ресурсов сервера. Вместо того чтобы каждый раз загружать потенциально большой файл, клиент может сначала вычислить его хэш (SHA256) и спросить у сервера, обрабатывался ли такой файл ранее.

**Почему это всё равно «запуск задачи», а не синхронный запрос?**

Причина в **единообразии API**. Чтобы не усложнять логику клиента, сервер всегда использует асинхронную модель с `task_id`:
1.  Клиент отправляет хэш.
2.  Сервер немедленно отвечает `202 Accepted` с `task_id`.
3.  В фоновом режиме запускается воркер, который проверяет наличие результата в кэше.
    *   **Если результат найден (cache hit):** Задача почти мгновенно переходит в статус `completed`.
    *   **Если результат не найден (cache miss):** Задача переходит в статус `failed` с ошибкой, сигнализируя клиенту, что необходимо загрузить файл целиком через `/api/v1/process`.

Таким образом, клиент всегда работает по одной и той же схеме: `создать задачу -> опрашивать статус -> получить результат`, что делает его реализацию проще и надежнее.

## 5. Нефункциональные требования к клиенту

*   **Надежность:**
    *   **Retries:** Клиент должен реализовывать политику повторных попыток (например, с exponential backoff) для всех HTTP-запросов на случай временных сетевых проблем или ошибок `5xx`.
    *   **Polling:** Интервал опроса статуса должен быть настраиваемым и не слишком частым, чтобы не создавать избыточную нагрузку на сервер (5-10 секунд — разумное значение).
*   **Обработка ошибок:**
    *   Клиент обязан корректно обрабатывать HTTP-коды: `202`, `400` (неверный запрос), `404` (задача не найдена), `5xx` (ошибка сервера).
    *   При статусе задачи `failed`, клиент должен отображать пользователю `error_message`.
*   **Конфигурация:** Адрес сервера должен быть легко изменяемым через параметры командной строки или конфигурационный файл.

## 6. Риски и компромиссы

1.  **Жизненный цикл задачи:** `TaskStore` хранит данные в памяти. Время жизни задачи и ее результата определяется параметром `cache_ttl` в конфигурации сервера. Если `GET /api/v1/tasks/{task_id}` возвращает `404 Not Found`, это означает, что либо `task_id` неверен, либо задача была удалена по истечении `cache_ttl`, либо сервер был перезапущен.
2.  **Отсутствие аутентификации:** API не защищен. Любой, кто знает `task_id`, может получить доступ к результату.
3.  **Ограничение на размер файла:** Клиенту следует проверять размер файла перед отправкой (лимит 10 МБ).

## 7. Чек-лист для разработки нового клиента

-   [ ] **1. Запуск задачи:** Реализована отправка `multipart/form-data` запроса на `POST /api/v1/process`.
-   [ ] **2. Получение Task ID:** Клиент корректно извлекает и сохраняет `task_id` из ответа `202 Accepted`.
-   [ ] **3. Опрос статуса:** Реализован механизм опроса `GET /api/v1/tasks/{task_id}`.
-   [ ] **4. Обработка статусов:** Клиент корректно обрабатывает все возможные статусы.
-   [ ] **5. Получение результата:** Клиент запрашивает `GET /api/v1/tasks/{task_id}/result` после получения статуса `completed`.
-   [ ] **6. Пагинация:** Клиент умеет обрабатывать пагинацию.
-   [ ] **7. Обработка ошибок:** Реализована логика для HTTP-ошибок (`404`, `5xx`) и для статуса `failed`.
-   [ ] **8. Конфигурация:** Адрес сервера вынесен в конфигурацию.
-   [ ] **9. (Опционально) Кэширование на клиенте:** Реализовано вычисление хэша файла и использование эндпоинта `POST /api/v1/process-by-hash`.